# End-to-End Terraformer Execution & Security Pipeline
*(UI → Backend → Terraformer → Security & Policy Outputs)*

---

## 1. Purpose of This Document

This document explains the **complete execution flow of the Terraform Assessment pipeline** in DevSecOps360.

It covers the journey **from a user entering details in the UI** to the **final assessment outputs** generated by the system, including:
- Terraformer execution
- Terraform plan generation (read-only)
- Security scanning (tfsec)
- Policy enforcement (OPA)

>  At no point does this pipeline apply or modify cloud resources.  
> The entire flow is **safe, read-only, and assessment-only**.

---

## 2. High-Level Architecture Flow

1. User enters assessment details in UI
2. UI sends request to Backend API
3. Backend triggers Python assessment engine
4. Python engine executes Terraformer / Terraform / Security tools
5. Outputs are generated in a structured run folder
6. Backend exposes results to UI using `run_id`

---

## 3. UI – User Input Details

The Terraform Assessment UI collects the following inputs:

### 3.1 Client ID *
- Logical identifier for the customer or project
- Used for tagging, metadata, and reporting

**Example:**
```

Client ID = ttms

```

---

### 3.2 Scope
- Defines *what part of the infrastructure* should be assessed
- Helps restrict Terraformer export to avoid unnecessary resources

**Example values:**
```

resource_group
virtual_network
network
storage_account

```

---

### 3.3 Cloud Provider *
- Selects the cloud environment for assessment

**Current support:**
```

Azure

````

(Future: AWS, GCP)

---

### 3.4 Subscription ID *
- Azure subscription from which infrastructure is read
- Requires **read-only permissions only**

---

### 3.5 Assessment Mode *
This field decides the **execution path**.

Available options:
- **From Existing Cloud**
- **From Terraform Repository**

---

## 4. Backend – Request Construction

When the user clicks **Submit**, the UI sends a JSON payload to the backend.

### 4.1 From Existing Cloud (Terraformer-based)

```json
{
  "scenario": "from-cloud",
  "client": "ttms",
  "resources": "resource_group,virtual_network",
  "cloud": {
    "subscription_id": "xxxx-xxxx-xxxx",
    "resource_group": "ttms-aks"
  }
}
````

---

### 4.2 From Terraform Repository

```json
{
  "scenario": "from-repo",
  "client": "ttms",
  "repo_path": "examples/tf_local"
}
```

---

## 5. Backend → Python Assessment Engine

The backend invokes the Python entrypoint:

```bash
python3 -m app.api_entry
```

* Input JSON is passed via **stdin**
* Python returns a response via **stdout**

**Initial response:**

```json
{
  "run_id": "2026-02-03T103853Z-unknown-93349f",
  "status": "IN_PROGRESS"
}
```

This `run_id` uniquely identifies the assessment execution.

---

## 6. Run Initialization (Common for All Scenarios)

For every run:

1. A unique `run_id` is generated
2. A dedicated folder is created:

```
runs/<run_id>/
├── metadata/
├── logs/
├── reports/
├── artifacts/
└── workspaces/
```

3. `metadata.json` is initialized with run context and status

---

## 7. Execution Flow – From Existing Cloud

### 7.1 Stage 1 – Terraformer Export

**Purpose:**

* Read existing Azure infrastructure (read-only)
* Convert it into Terraform code

**Output:**

```
runs/<run_id>/artifacts/terraformer/azurerm/<service>/
runs/<run_id>/logs/terraformer.log
runs/<run_id>/reports/stage1_terraformer.json
```

---

### 7.2 Stage 1.5 – Workspace Normalization

Terraformer output is not always plan-ready.

This stage:

* Adds provider blocks
* Pins provider versions
* Fixes known AzureRM issues
* Formats Terraform files

**Output:**

```
runs/<run_id>/workspaces/plan/
runs/<run_id>/logs/terraform_prepare.log
runs/<run_id>/reports/stage1_5_prepare_plan_workspace.json
```

---

### 7.3 Stage 2 – Terraform Init & Plan (Read-only)

Commands executed:

* `terraform init`
* `terraform validate`
* `terraform plan`

> No backend, no apply, no state persistence.

**Output:**

```
runs/<run_id>/reports/tf/tfplan.bin
runs/<run_id>/reports/tf/tfplan.json
runs/<run_id>/logs/terraform_plan.log
```

---

### 7.4 Stage 3 – tfsec (Security Scan)

Static analysis of Terraform code to detect misconfigurations.

**Output:**

```
runs/<run_id>/reports/iac/tfsec.json
runs/<run_id>/logs/tfsec.log
```

---

### 7.5 Stage 4 – OPA (Policy Check)

OPA evaluates the **Terraform plan JSON**, not raw code.

**Output:**

```
runs/<run_id>/reports/opa/opa_decision.json
runs/<run_id>/logs/opa_tfplan.log
```

---

### 7.6 Final Status Update

`metadata.json` is updated with final result:

Possible statuses:

* `POLICY_PASSED`
* `POLICY_FAILED`
* `FAILED`

---

## 8. Execution Flow – From Terraform Repository

Terraformer is skipped.

Steps executed:

1. Copy Terraform code into workspace
2. Terraform init & plan
3. tfsec scan
4. OPA policy evaluation

**Outputs generated are identical to cloud-based execution**, except Terraformer artifacts.

---

## 9. Final Output Structure (Single Source of Truth)

```
runs/<RUN_ID>/
├── metadata/
│   └── metadata.json
├── logs/
│   ├── terraformer.log
│   ├── terraform_prepare.log
│   ├── terraform_plan.log
│   ├── tfsec.log
│   └── opa_tfplan.log
├── reports/
│   ├── stage1_terraformer.json
│   ├── stage1_5_prepare_plan_workspace.json
│   ├── iac/
│   │   └── tfsec.json
│   ├── tf/
│   │   └── tfplan.json
│   └── opa/
│       └── opa_decision.json
├── artifacts/
│   └── terraformer/
└── workspaces/
    └── plan/
```

---

## 10. How UI Consumes Results

* **Status** → `metadata.json`
* **Security findings** → `tfsec.json`
* **Planned changes** → `tfplan.json`
* **Policy decision** → `opa_decision.json`

UI renders:

* Pass / Fail status
* Security severity summary
* Policy violations
* Detailed findings per resource

---

## 11. Demo Execution (CLI Reference)

### 11.1 From Existing Cloud Demo

```bash
cat <<'JSON' | python3 -m app.api_entry
{
  "scenario": "from-cloud",
  "client": "ttms",
  "resources": "resource_group,virtual_network",
  "cloud": {
    "resource_group": "ttms-aks"
  }
}
JSON
```

---

### 11.2 From Terraform Repository Demo

```bash
cat <<'JSON' | python3 -m app.api_entry
{
  "scenario": "from-repo",
  "client": "ttms",
  "repo_path": "examples/tf_local"
}
JSON
```

---

## 12. Key Takeaway (For Leadership)

DevSecOps360 provides a **safe, automated, and repeatable Terraform assessment pipeline** that converts cloud or repository infrastructure into a Terraform plan and evaluates it using security and policy controls—**without applying any changes**.

---

**END OF DOCUMENT**
